## Part 1. Установка ОС

**== Задание ==**

Установить Ubuntu 20.04 Server LTS без графического интерфейса. (Используем программу для виртуализации - VirtualBox)

- Графический интерфейс должен отсутствовать.

- Узнайте версию Ubuntu, выполнив команду 
`cat /etc/issue`.

- Вставьте скриншот с выводом команды.

**== Выполнение ==**

![image info](.\image\part1.png)


## Part 2. Создание пользователя

**== Задание ==**

Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен быть добавлен в группу adm.

Вставьте скриншот вызова команды для создания пользователя.
Новый пользователь должен быть в выводе команды 
cat /etc/passwd

Вставьте скриншот с выводом команды.

**== Выполнение ==**

- Создадим нового пользователя _user_21_ с помощью команды `sudo adduser user_21`

![image info](.\image\part2_1.png)

- Добавим данного пользователя в группу _adm_: `sudo usermod -a -G adm user_21`

![image info](.\image\part2_2.png)

- Введем команду `cat /etc/passwd`

- Проверим, что информация о пользователе _user_21_ присутствует в выводе:

![image info](.\image\part2_3.png)

## Part 3. Настройка сети ОС

**== Задание ==**

Задать название машины вида user-1

Установить временную зону, соответствующую вашему текущему местоположению.

Вывести названия сетевых интерфейсов с помощью консольной команды.

- В отчёте дать объяснение наличию интерфейса lo.


Используя консольную команду получить ip адрес устройства, на котором вы работаете, от DHCP сервера.

- В отчёте дать расшифровку DHCP.


Определить и вывести на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw).

Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8).

Перезагрузить виртуальную машину. Убедиться, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте.


- В отчёте опишите, что сделали для выполнения всех семи пунктов (можно как текстом, так и скриншотами).
- Успешно пропинговать удаленные хосты 1.1.1.1 и ya.ru и вставить в отчёт скрин с выводом команды. В выводе команды должна быть фраза "0% packet loss".

**== Выполнение ==**


- Введем команду `sudo hostname user-1`, чтобы задать имя хоста, которое сохранится и при перезапуске виртуальной машины
![image info](.\image\part3_1.png)

---

- Введем команду sudo timedatectl `set-timezone Europe/Samara` и проверим, что временная зона была изменена

![image info](.\image\part3_2.png)

---

- Выведем названия сетевых интерфейсов при помощи `ip -br link show`

![image info](.\image\part3_3.png)

При выводе команды видно наличие интерфейса lo

> **lo** (интерфейс loopback) — виртуальный интерфейс, который по умолчанию присутствует в любом Linux. Он используется сетевым клиентским программным обеспечением, чтобы общаться с серверным приложением, расположенным на том же компьютере. Наиболее широко используемый IP адрес в механизмах loopback — 127.0.0.1.
---

- Получим ip-адрес устройства от DHCP-сервера

![image info](.\image\part3_4.png)

Можно сделать вывод, что DHCP-сервер предложил используемому устройству адрес _10.0.2.0/24_, после чего он его использлование было подтверждено, и адрес закрепился за устройством.

> **DHCP** (англ. Dynamic Host Configuration Protocol — протокол динамической настройки узла) — сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. 

---

- Чтобы найти и отобразить внутренний IP-адрес шлюза (IP по умолчанию), используйте следующую команду: `ip addr show`

Внутренний IP-адрес шлюза

![image info](.\image\part3_5.png)

Выведем внешний ip-адрес шлюза с помощью команды `curl icanhazip.com`

![image info](.\image\part3_6.png)

---

- Зададим статичные настройки ip, gw, dns.

-Откройте файл interfaces с помощью текстового редактора и прав администратора: $ sudo nano /etc/network/interfaces `sudo nano /etc/network/interfaces`

- новые значения: введите новый IP, шлюз, маску, dns

![image info](.\image\part3_7.png)


---

- Пропингуем удаленные хосты 1.1.1.1 и ya.ru

![image info](.\image\part3_8.png)

## Part 4

**== Задание ==**

- Обновить системные пакеты до последней на момент выполнения задания версии.

- После обновления системных пакетов, если ввести команду обновления повторно, должно появится сообщение, что обновления отсутствуют.

**== Выполнение ==**

- Для обновления системынх пакетов используем команды _update_ для синхронизации индекса пакетов из репозиториев и _upgrade_  для установки самых новых версий пакетов, установленных в системе

![image info](.\image\part4_1.png)

![image info](.\image\part4_2.png)

- Проверим, что сисетма была обновлена, повторно введя sudo apt-get upgrade и получив сообщение об обновлении 0 пакетов

![image info](.\image\part4_.png)

## Part 5

**== Задание ==**

Разрешить пользователю, созданному в Part 2, выполнять команду sudo.

- В отчёте объяснить истинное назначение команды sudo.
- Поменять hostname ОС от имени пользователя, созданного в пункте Part 2 (используя sudo).

**== Выполнение ==**

- Добавим пользователя _user_21_ в группу _sudo_

![image info](.\image\part5_1.png)

- Сменим пользователя на schol21_user с помощью команды su, введя пароль, заданный в Part 2 при создании пользователя

![image info](.\image\part5_2.png)

- Поменяем _hostmame_ от лица пользователя _user_21_

![image info](.\image\part5_3.png)

> **sudo** (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы. Основная идея — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач.

## Part 6. Установка и настройка службы времени

**== Задание ==**

- Настроить службу автоматической синхронизации времени.
- Вывести время, часового пояса, в котором вы сейчас находитесь.
- Вывод следующей команды должен содержать NTPSynchronized=yes: 
timedatectl show

**== Выполнение ==**

![image info](.\image\part6.png)

## Part 7. Установка и использование текстовых редакторов

**Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)**

**Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений.**


- В отчёт вставьте скриншоты:
    - Из каждого редактора с содержимым файла перед закрытием.
- В отчёте укажите, что сделали для выхода с сохранением изменений.


**Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений.**

- В отчёт вставьте скриншоты:
    -  Из каждого редактора с содержимым файла после редактирования.
- В отчёте укажите, что сделали для выхода без сохранения изменений.


**Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое.**

- В отчёт вставьте скриншоты:
    - Из каждого редактора с результатами поиска слова.
- Из каждого редактора с командами, введёнными для замены слова на другое.

**== Выполнение ==**


---

- Запишем ник с помощью _vim_

![image info](.\image\part7_1.png)
- Для выхода с сохранением после нажатия _esc_ введем _:x_

![image info](.\image\part7_2.png)
---

- Запишем ник с помощью _nano_

![image info](.\image\part7_3.png)

- Для выхода с сохранением воспользуемся _ctrl+x_ и при возникновении вопроса `Save modified buffer?` выберем _Y_

---

- Запишем ник с помощью _mcedit_

![image info](.\image\part7_4.png)

- Для выхода с сохранением воспользуемся _fn f2 + fn f10_

---

- Проверим, что были созданы файлы, содержащие ник _vineroos_

![image info](.\image\part7_5.png)

---

- Изменим test_vim.txt

![image info](.\image\part7_6.png)

- Для выхода без сохранения изменений после нажатия _esc_ введем _:q!_

---

- Изменим test_nano.txt

![image info](.\image\part7_7.png)

- Для выхода без сохранения изменений после _ctrl+x_ при возникновении `Save modified buffer?` выберем _N_

---

- Изменим test_mcedit.txt

![image info](.\image\part7_8.png)

- Для выхода без сохранения изменений после _fn f10_ при возникновении `Отменить изменения файла?` выберем _no_

---

- Отредактируем _test_vim.txt_ еще раз, сохранив изменения. После найдем слово _School_

![image info](.\image\part7_9.png)

- Заменим _School_ на _vineroos_

![image info](.\image\part7_10.png)

- Выйдем, сохранив изменения

---

- Отредактируем _test_nano.txt_ и сохраним изменения. Найдем _School_. Для этого воспользуемся _ctrl+W_, введем слово, нажмем _enter_

![image info](.\image\part7_11.png)

![image info](.\image\part7_12.png)

- В результате сообщается о количестве совпадений, а курсор перемещается на начало найденной строки

- Заменим _School_ на _vineroos_. Для этого воспользуемся _ ctrl+\ _, введем заменяемое слово, нажмем enter

![image info](.\image\part7_13.png)

- Вводим слово для замены, нажимаем _enter_

![image info](.\image\part7_14.png)

- Подтверждаем замену, выбрав _Y_

![image info](.\image\part7_15.png)

- В резултате получаем новое слово, выходим с сохранением

![image info](.\image\part7_16.png)

---

- Отредактируем _test_mcedit.txt_ и сохраним изменения. Найдем _School_. Для этого воспользуемя сочетанием _fn f7_

![image info](.\image\part7_17.png)


- В результате слов выделится 


- Заменим все вхождения _School_ на _vineroos_. Для этого воспользуемся _fn f4_, введем Заменяемое слово, нажмем _enter_

![image info](.\image\part7_18.png)

---

Проверим, что все изменения были сохранены

![image info](.\image\part7_19.png)


## Part 8. Установка и базовая настройка сервиса SSHD

**== Задание ==**

**Установить службу SSHd.**

**Добавить автостарт службы при загрузке системы.**

**Перенастроить службу SSHd на порт 2022.**

**Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи.**


- В отчёте объяснить значение команды и каждого ключа в ней.


**Перезагрузить систему.**

- В отчёте опишите, что сделали для выполнения всех пяти пунктов (можно как текстом, так и скриншотами).
- Вывод команды netstat -tan должен содержать `tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN` (если команды netstat нет, то ее нужно установить)
- Скрин с выводом команды вставить в отчёт.
- В отчёте объяснить значение ключей -tan, значение каждого столбца вывода, значение 0.0.0.0.

**== Выполнение ==**

- Установим _SSH_:

![image info](.\image\part8_1.png)

- Установим _openssh_ (в данном случае сообщается о том, что _openssh_ уже установлен)

![image info](.\image\part8_2.png)

- Проверяем, что автостарт службы при загрузке системы был добавлен. На это указывает _enabled_ в _Loaded_

![image info](.\image\part8_3.png)


- Выполним _sudo nano /etc/ssh/sshd_config_

![image info](.\image\part8_4.png)

- Поменяем _Port_ на _2022_ и выйдем, сохранив изменения. 

![image info](.\image\part8_5.png)

- Перезапустим службу SSH, чтобы изменения вступили в силу: `sudo systemctl restart ssh`

- Проверим, запущен ли ssh-демон на вашем сервере с помощью команды ps

![image info](.\image\part8_6.png)

> Команда **_ps_**, сокращенно от _Process Status_, представляет собой утилиту командной строки, которая используется для отображения или просмотра информации, связанной с процессами, запущенными в системе Linux.

> **_a_** отображает идентификаторы процессов и состояние идентификатора сеанса для каждого реального пользователя.

> **_u_** — это ширина экрана по умолчанию и формат виртуальной памяти с более ценными функциями, а также общая пользовательская настройка управления форматом вывода.

> **_x_** предоставляет следующие столбцы: PID, TTY, STAT, TIME, COMMAND. Вывод «x» аналогичен выводу «u», но разница в том, что «x» отображает процессы, которые выполняются без привязки к какому-либо экрану терминала.

> **_grep sshd_** выводит строки, содержащие _sshd_

- Выполним _reboot_ и _netstat -tan_

![image info](.\image\part8_7.png)

> **_a_** выводит список всех портов и соединений независимо от их состояния или протокола

> **_t_** выводит порты tcp

> **_n_** показывает числовые адреса

> **_tan_** выведет список всех портов TCP с с отображением адресов и номеров портов

- **Значения столблов:**

> **_Proto_** — Протокол (tcp, udp, raw), используемый сокетом.

> **_Reqv-Q_** — Счётчик байт не скопированных программой пользователя из этого сокета.

> **_Send-Q_** — Счётчик байтов, не подтверждённых удалённым узлом.

> **_Local Address_** — Адрес и номер порта локального конца сокета.

> **_Foreign Address_** — Адрес и номер порта удалённого конца сокета. 

> **_State_** — Состояние сокета. **_LISTEN_** — Сокет ожидает входящих подключений.

- **Значение 0.0.0.0.**

> **_IP-адрес 0.0.0.0_** — это немаршрутизируемый адрес IPv4, который можно использовать в разных целях, в основном, в качестве адреса по умолчанию или адреса-заполнителя. Он действует как резервный, пока не будет назначен действительный маршрутизируемый IP-адрес.


## Part 9. Установка и использование утилит top, htop

**== Задание ==**

**Установить и запустить утилиты top и htop.**

- По выводу команды top определить и написать в отчёте:
    - uptime
    - количество авторизованных пользователей
    - общую загрузку системы
    - общее количество процессов
    - загрузку cpu
    - загрузку памяти
    - pid процесса занимающего больше всего памяти
    - pid процесса, занимающего больше всего процессорного времени
- В отчёт вставить скрин с выводом команды htop:
    - отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME
    - отфильтрованному для процесса sshd
    - с процессом syslog, найденным, используя поиск
    - с добавленным выводом hostname, clock и uptime

**== Выполнение ==**

- Установим _htop_ `sudo apt install htop`
- Выполним top

![image info](.\image\part9_1.png)

    - uptime: 10 минут
    - количество авторизованных пользователей: 1
    - общую загрузку системы: 0,00
    - общее количество процессов: 95
    - загрузку cpu: 0.0%
    - загрузку памяти: 140.6 из 1971.4
    - pid процесса занимающего больше всего памяти: 1
    - pid процесса, занимающего больше всего процессорного времени: 159

- _htop_, отсортированный по _PID_

![image info](.\image\part9_2.png)

- _htop_, отсортированный по _PERCENT_CPU_

![image info](.\image\part9_3.png)

- _htop_, отсортированный по _PERCENT_MEM_

![image info](.\image\part9_4.png)

- _htop_, отсортированный по _TIME_

![image info](.\image\part9_5.png)

- _htop_, отфильтрованный для процесса _sshd_

![image info](.\image\part9_6.png)

- _htop_, с найденным с помощбю поиска процессом syslog

![image info](.\image\part9_7.png)

- Добавленный вывод hostname, clock и uptime

![image info]()


## Part 10. Использование утилиты fdisk

**== Задание ==**

**Запустить команду fdisk -l.**

- В отчёте написать название жесткого диска, его размер и количество секторов, а также размер swap.

**== Выполнение ==**

![image info](.\image\part10_1.png)

- Название: VBOX HARDDISK
- Размер: 10 Гб
- Количество секторов: 20971520
- Размер swap: 0 байт

![image info](.\image\part10_2.png)

## Part 11. Part 11. Использование утилиты df

**== Задание ==**

**Запустить команду df.**

- В отчёте написать для корневого раздела (/):
    - размер раздела
    - размер занятого пространства
    - размер свободного пространства
    - процент использования

- Определить и написать в отчёт единицу измерения в выводе.

**Запустить команду df -Th.**

- В отчёте написать для корневого раздела (/):
    - размер раздела
    - размер занятого пространства
    - размер свободного пространства
    - процент использования

- Определить и написать в отчёт тип файловой системы для раздела.

**== Выполнение ==**

- Выполним `df`

![image info](.\image\part11_1.png)

    - размер раздела: 9182548 Кб
    - размер занятого пространства: 4991180 Кб
    - размер свободного пространства: 3703332 Кб
    - процент использования: 58%

- Единица измерения: Кб (по умолчанию количество места на дисках выводится в килобайтах, если не указан какой-либо ключ)

- Выполним `df -Th`

![image info](.\image\part11_2.png)

    - размер раздела: 8.8 Гб
    - размер занятого пространства: 4.8 Гб
    - размер свободного пространства: 3.6 Гб
    - процент использования: 58%
- Тип файловой системы для раздела: ext4 ((англ. fourth extended file system, ext4fs) — журналируемая файловая система)


## Part 12. Использование утилиты du

**== Задание ==**

**Запустить команду du.**

**Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)**

**Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента)**


**== Выполнение ==**

- Выполним `du`

![image info](.\image\part12_1.png)

- Выведем размер папок _/home_, _/var_, _/var/log_ в человекочитаемом виде в байтах 

![image info](.\image\part12_2.png)

- Выведем размер каждого вложенного элемента в _/var/log_

![image info](.\image\part12_3.png)


## Part 13. Установка и использование утилиты ncdu

**== Задание ==**

**Установить утилиту ncdu.**

**Вывести размер папок /home, /var, /var/log.**

- Размеры должны примерно совпадать с полученными в Part 12.


**== Выполнение ==**

- Установим _ncdu_

![image info](.\image\part13_1.png)

- Выведем размер папки _/home_

![image info](.\image\part13_2.png)

- Выведем размер папки _/var_

![image info](.\image\part13_3.png)

- Выведем размер папки _/var/log_

![image info](.\image\part13_4.png)


## Part 14. Работа с системными журналами

**== Задание ==**

**Открыть для просмотра:**

1. /var/log/dmesg

2. /var/log/syslog

3. /var/log/auth.log

- Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему.
- Перезапустить службу SSHd.
- Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах).

**== Выполнение ==**

- Откроем для просмотра _/var/log/dmesg_

![image info](.\image\part14_1.png)

- Откроем для просмотра _/var/log/syslog_

![image info](.\image\part14_2.png)

- Откроем для просмотра _/var/log/auth.log_ 

![image info](.\image\part14_3.png)

- Время последней успешной авторизации: _19:51:12_
- Имя пользователя: _vineroos_
- Метод входа в систему: by uid = 0 (User Identifier). Суперпользователь всегда должен иметь UID, равный нулю.

- Перезапустим службу SSHd: `systemctl restart ssh`

![image info](.\image\part14_4.png)

- Найдем в _/var/log/auth.log_ сообщение о рестарте службы _sshd_

![image info](.\image\part14_5.png)


## Part 15. Использование планировщика заданий CRON

**== Задание ==**

**Используя планировщик заданий, запустите команду uptime через каждые 2 минуты.**

- Найти в системных журналах строчки (минимум две в заданном временном диапазоне) о выполнении.
- Вывести на экран список текущих заданий для CRON.
- Вставить в отчёт скрины со строчками о выполнении и списком текущих задач.

**Удалите все задания из планировщика заданий.**

- В отчёт вставьте скрин со списком текущих заданий для CRON.

**== Выполнение ==**

- Создадим файл расписания для текущего пользователя: `crontab -e`

![image info](.\image\part15_1.png)

- Просмотрим список текущих заданий для CRON

![image info](.\image\part15_2.png)

- Найдем в системном журнале строчки о выполнении _uptime_

![image info](.\image\part15_3.png)

- Удалим все задания из планировщика и проверим, что список заданий пуст 

![image info](.\image\part15_4.png)





